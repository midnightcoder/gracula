/*
 * tests/reasoning/FormulaKitUTest.cxxtest
 *
 * Copyright (C) 2002-2007 Novamente LLC
 * All Rights Reserved
 *
 * Original written by Ari A. Heljakka
 * Modified by Jared Wigmore <jared.wigmore@gmail.com> 2008
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/reasoning/pln/formulas/Formulas.h>
#include <opencog/atomspace/TruthValue.h>
#include <opencog/atomspace/SimpleTruthValue.h>
#include <opencog/atomspace/CompositeTruthValue.h>
#include <opencog/atomspace/utils.h> //#include <utils2.h>

#include <math.h>
#define NUM_ATOMS 5
#define STRENGTH_EPSILON 0.1
#define COUNT_EPSILON 5

using namespace std;

class FormulasKitUTest : public CxxTest::TestSuite {
private:
//    SimpleTruthValue* atoms[NUM_ATOMS];
    TruthValue* atoms[NUM_ATOMS];
    SimpleTruthValue* inheritance[NUM_ATOMS][NUM_ATOMS];
    SimpleTruthValue* similarity[NUM_ATOMS][NUM_ATOMS];

public:
    FormulasKitUTest() {
        atoms[0] = new SimpleTruthValue(0.36,36.0);
        atoms[1] = new SimpleTruthValue(0.49,49.0);
        atoms[2] = new SimpleTruthValue(0.42,42.0);
        atoms[3] = new SimpleTruthValue(0.45,45.0);
        atoms[4] = new SimpleTruthValue(0.41,41.0);

        inheritance[0][1] = new SimpleTruthValue(0.5277778,36);
        inheritance[0][2] = new SimpleTruthValue(0.44444445,36);
        inheritance[0][3] = new SimpleTruthValue(0.5277778,36);
        inheritance[0][4] = new SimpleTruthValue(0.3888889,36);
        inheritance[1][0] = new SimpleTruthValue(0.3877551,49);
        inheritance[1][2] = new SimpleTruthValue(0.48979592,49);
        inheritance[1][3] = new SimpleTruthValue(0.5102041,49);
        inheritance[1][4] = new SimpleTruthValue(0.42857143,49);
        inheritance[2][0] = new SimpleTruthValue(0.3809524,42);
        inheritance[2][1] = new SimpleTruthValue(0.5714286,42);
        inheritance[2][3] = new SimpleTruthValue(0.4047619,42);
        inheritance[2][4] = new SimpleTruthValue(0.42857143,42);
        inheritance[3][0] = new SimpleTruthValue(0.42222223,45);
        inheritance[3][1] = new SimpleTruthValue(0.5555556,45);
        inheritance[3][2] = new SimpleTruthValue(0.37777779,45);
        inheritance[3][4] = new SimpleTruthValue(0.4,45);
        inheritance[4][0] = new SimpleTruthValue(0.34146342,41);
        inheritance[4][1] = new SimpleTruthValue(0.5121951,41);
        inheritance[4][2] = new SimpleTruthValue(0.4390244,41);
        inheritance[4][3] = new SimpleTruthValue(0.4390244,41);

        similarity[0][1] = new SimpleTruthValue(0.28787878,66);
        similarity[0][2] = new SimpleTruthValue(0.2580645,62);
        similarity[0][3] = new SimpleTruthValue(0.30645162,62);
        similarity[0][4] = new SimpleTruthValue(0.22222222,63);
        similarity[1][0] = new SimpleTruthValue(0.28787878,66);
        similarity[1][2] = new SimpleTruthValue(0.35820895,67);
        similarity[1][3] = new SimpleTruthValue(0.36231884,69);
        similarity[1][4] = new SimpleTruthValue(0.3043478,69);
        similarity[2][0] = new SimpleTruthValue(0.2580645,62);
        similarity[2][1] = new SimpleTruthValue(0.35820895,67);
        similarity[2][3] = new SimpleTruthValue(0.24285714,70);
        similarity[2][4] = new SimpleTruthValue(0.2769231,65);
        similarity[3][0] = new SimpleTruthValue(0.30645162,62);
        similarity[3][1] = new SimpleTruthValue(0.36231884,69);
        similarity[3][2] = new SimpleTruthValue(0.24285714,70);
        similarity[3][4] = new SimpleTruthValue(0.2647059,68);
        similarity[4][0] = new SimpleTruthValue(0.22222222,63);
        similarity[4][1] = new SimpleTruthValue(0.3043478,69);
        similarity[4][2] = new SimpleTruthValue(0.2769231,65);
        similarity[4][3] = new SimpleTruthValue(0.2647059,68);
    }

    void testSimpleFormulas() {
        printf("testSimpleFormulas()\n");
        TruthValue* resultTv = opencog::pln::OldANDFormula().compute(atoms, 2);
        TS_ASSERT(resultTv);
        printf("resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::SymmetricANDFormula().compute(atoms, 4);
        TS_ASSERT(resultTv);
        printf("symmetric resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::AsymmetricANDFormula().compute(atoms, 2);
        TS_ASSERT(resultTv);
        printf("asymmetric resultTv = %s\n", resultTv->toString().c_str());
    }
    
    void testMultiCompute() {
        printf("testMultiCompute()\n");
        TruthValue** multiResult;
        multiResult = opencog::pln::OldANDFormula().multiCompute(atoms, 4);
        for (int i = 0; i < 2; i++) {
            TS_ASSERT(multiResult[i]);
            printf("multiResult[%d] = %s\n", i, multiResult[i]->toString().c_str());
        }
        TruthValue* resultTv = opencog::pln::OldANDFormula().compute(multiResult, 2);
        TS_ASSERT(resultTv);
        printf("resultTv = %s\n", resultTv->toString().c_str());
    }
    
    void testCompositeFormulas() {
        printf("testCompositeFormulas()\n");
        TruthValue* resultTv;
        
        // run compute over Default TVS, just to compare with primary TVS
        printf("======== PHASE 0: DefaultTVs ==========\n");
        TruthValue* defaultTVs[NUM_ATOMS];
        for (int i = 0; i < NUM_ATOMS; i++) {
            defaultTVs[i] = (TruthValue*) &(TruthValue::DEFAULT_TV());
        }
        resultTv = opencog::pln::OldANDFormula().compute(defaultTVs, 2);
        TS_ASSERT(resultTv);
        printf("resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::SymmetricANDFormula().compute(defaultTVs, 4);
        TS_ASSERT(resultTv);
        printf("symmetric resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::AsymmetricANDFormula().compute(defaultTVs, 2);
        TS_ASSERT(resultTv);
        printf("asymmetric resultTv = %s\n", resultTv->toString().c_str());
        

        // run simplecompute with the same SimpleTruthValues. Must get same results...
        printf("======== PHASE 1: SimpleTVs ==========\n");
        resultTv = opencog::pln::OldANDFormula().simpleCompute(atoms, 2);
        TS_ASSERT(resultTv);
        printf("resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::SymmetricANDFormula().simpleCompute(atoms, 4);
        TS_ASSERT(resultTv);
        printf("symmetric resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::AsymmetricANDFormula().simpleCompute(atoms, 2);
        TS_ASSERT(resultTv);
        printf("asymmetric resultTv = %s\n", resultTv->toString().c_str());
        
        // Now run with CompositeTruthValues
        printf("======== PHASE 1: CompositeTVs ==========\n");
        TruthValue* compositeTVs[NUM_ATOMS];
        for (int i = 0; i < NUM_ATOMS; i++) {
            compositeTVs[i] = new CompositeTruthValue(*(atoms[i]), VersionHandle(HYPOTHETICAL, Handle::UNDEFINED));
        }
        // run with the same SimpleTruthValues. Must get same results...
        resultTv = opencog::pln::OldANDFormula().compute(compositeTVs, 2);
        TS_ASSERT(resultTv);
        printf("resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::SymmetricANDFormula().compute(compositeTVs, 4);
        TS_ASSERT(resultTv);
        printf("symmetric resultTv = %s\n", resultTv->toString().c_str());
        resultTv = opencog::pln::AsymmetricANDFormula().compute(compositeTVs, 2);
        TS_ASSERT(resultTv);
        printf("asymmetric resultTv = %s\n", resultTv->toString().c_str());
    }
    
    void DISABLEtestBoundaries() {
        int N = 8;
        SimpleTruthValue* v[] = {
            new SimpleTruthValue(0.0,1),
            new SimpleTruthValue(0.0,100),
            new SimpleTruthValue(1.0,1),
            new SimpleTruthValue(1.0,100),
            new SimpleTruthValue(0.01,1),
            new SimpleTruthValue(0.01,100),
            new SimpleTruthValue(0.99,1),
            new SimpleTruthValue(0.99,100),
            new SimpleTruthValue(-1,100),
            new SimpleTruthValue(100,100)
        };
        TruthValue* t;
#ifdef OLD_BORKEN_CODE
//! @todo PTLFormulaeKit is from  old implementation
        for (int a=0; a < N; a++) {
            for (int b=0; b < N; b++) {
                for (int c=0; c < N; c++) {
                    for (int d=0; d < N; d++) {
                        for (int e=0; e < N; e++) {
                            t = PTLFormulaeKit::deduction(v[a], v[b], v[c], v[d], v[e]);
                            if (t!=NULL) TS_ASSERT((t->getMean()>=0) && (t->getMean()<=1)&&(t->getCount()>0));
                        }
                        t = PTLFormulaeKit::inheritanceToSimilarity(v[a],v[b],v[c],v[d]);
                        if (t!=NULL) ((t->getMean()>=0) && (t->getMean()<=1)&&(t->getCount()>0));
                    }
                    t = PTLFormulaeKit::inversion(v[a],v[b],v[c]);
                    if (t!=NULL) TS_ASSERT((t->getMean()>=0) && (t->getMean()<=1)&&(t->getCount()>0));
                    t = PTLFormulaeKit::nodeTruthValue(v[a],v[b],v[c]);
                    if (t!=NULL) TS_ASSERT((t->getMean()>=0) && (t->getMean()<=1)&&(t->getCount()>0));
                    t = PTLFormulaeKit::similarityToInheritance(v[a],v[b],v[c],false);
                    if (t!=NULL) TS_ASSERT((t->getMean()>=0) && (t->getMean()<=1)&&(t->getCount()>0));
                }
                t = PTLFormulaeKit::revision(v[a],v[b]);
                if (t!=NULL) TS_ASSERT((t->getMean()>=0) && (t->getMean()<=1)&&(t->getCount()>0));
            }
        }
#endif
    }

    void DISABLEtestDeductionSetWorld() {
        cout << "\n"
             // << "A->B\t\t\tB->C\t\t\tA\t\t\tB\t\t\tC\t\t\tA->C(expected)\t\tA->C(inferred)\n";
             << "A->B\t\t\tB->C\t\t\tA->C(expected)\t\tA->C(inferred)\n";
        TruthValue* t = NULL;
        TruthValue* e = NULL;
        float totalStrError = 0;
        float totalCountError = 0;
        int num = 0;
        for (int i=0; i < NUM_ATOMS; i++) {
            for (int j=0; j < NUM_ATOMS; j++) {
                for (int m=0; m < NUM_ATOMS; m++) {
                    for (int n=0; n < NUM_ATOMS; n++) {
                        if ((i!=n)&&(j==m)) {
                            if ((inheritance[i][j]==NULL) || (inheritance[m][n]==NULL)) continue;




                            // TS_ASSERT(t!=NULL);
                            e = inheritance[i][n];
                            cout << inheritance[i][j]->toString() << "\t"
                                 << inheritance[m][n]->toString() << "\t"
                                 //<< atoms[i]->toString() << "\t"
                                 //<< atoms[j]->toString() << "\t"
                                 //<< atoms[n]->toString() << "\t"
                                 << e->toString() << "\t"
                                 << t->toString() << "\n";
                            totalStrError += abs(e->getMean() - t->getMean());
                            totalCountError += abs(e->getCount() - t->getCount());
                            num++;
                        }
                    }
                }
            }
        }
        float averageStrengthError = totalStrError / num;
        float averageCountError = totalCountError / num;
        cout << "Average Strength Error:" << averageStrengthError << "\n";
        cout << "Average Count Error:" << averageCountError << "\n";
        if (t!=NULL) TS_ASSERT(averageStrengthError < STRENGTH_EPSILON);
        if (t!=NULL) TS_ASSERT(averageCountError < COUNT_EPSILON);
    }

    void DISABLEtestInversionSetWorld() {
        cout << "\n"
             << "B->A\t\t\tA\t\t\tB\t\t\tA->B(expected)\t\tA->B(inferred)\n";
        TruthValue* t=NULL;
        TruthValue* e;
        float totalStrError = 0;
        float totalCountError = 0;
        int num = 0;
        for (int b=0; b < NUM_ATOMS; b++) {
            for (int a=0; a < NUM_ATOMS; a++) {
                if (a==b) continue;
                if (inheritance[a][b]==NULL) continue;
#ifdef OLD_BROKEN_CODE
//! @todo PTLFormulaeKit is from  old implementation
                t = PTLFormulaeKit::inversion(inheritance[b][a],atoms[a],atoms[b]);

                TS_ASSERT(t!=NULL);
                e = inheritance[a][b];
                cout << inheritance[b][a]->toString() << "\t"
                     << atoms[a]->toString() << "\t"
                     << atoms[b]->toString() << "\t";
                cout << e->toString() << "\t";
                cout << t->toString() << "\n";
                totalStrError += abs(e->getMean() - t->getMean());
                totalCountError += abs(e->getCount() - t->getCount());
#endif
                num++;
            }
        }
        float averageStrengthError = totalStrError / num;
        float averageCountError = totalCountError / num;
        cout << "Average Strength Error:" << averageStrengthError << "\n";
        cout << "Average Count Error:" << averageCountError << "\n";
        if (t!=NULL) TS_ASSERT(averageStrengthError < STRENGTH_EPSILON);
        if (t!=NULL) TS_ASSERT(averageCountError < COUNT_EPSILON);
    }

    void DISABLEtestNodeTruthValue() {
        cout << "\n"
             << "A->B\t\t\tB->A\t\t\tB\t\t\tA(expected)\t\tA(inferred)\n";
        TruthValue* t=NULL;
        TruthValue* e;
        float totalStrError = 0;
        float totalCountError = 0;
        int num = 0;
        for (int a=0; a < NUM_ATOMS; a++) {
            for (int b=0; b < NUM_ATOMS; b++) {
                if (a==b) continue;
                if ((inheritance[a][b]==NULL)||(inheritance[b][a]==NULL)) continue;

#ifdef OLD_BROKEN_CODE
//! @todo PTLFormulaeKit is from  old implementation
                t = PTLFormulaeKit::nodeTruthValue(inheritance[a][b],inheritance[b][a],atoms[b]);

                TS_ASSERT(t!=NULL);
                e = atoms[a];
                cout << inheritance[a][b]->toString() << "\t"
                     << inheritance[b][a]->toString() << "\t"
                     << atoms[b]->toString() << "\t"
                     << e->toString() << "\t"
                     << t->toString() << "\n";
                totalStrError += abs(e->getMean() - t->getMean());
                totalCountError += abs(e->getCount() - t->getCount());
#endif
                num++;
            }
        }
        float averageStrengthError = totalStrError / num;
        float averageCountError = totalCountError / num;
        cout << "Average Strength Error:" << averageStrengthError << "\n";
        cout << "Average Count Error:" << averageCountError << "\n";
        if (t!=NULL) TS_ASSERT(averageStrengthError < STRENGTH_EPSILON);
        if (t!=NULL) TS_ASSERT(averageCountError < COUNT_EPSILON);
    }

    void DISABLEtestSimilarityToInheritance() {
        cout << "\n"
             << "A<->B\t\t\tA\t\t\tB\t\t\tA->B(expected)\t\tA->B(inferred)\n";
        TruthValue* t;
        TruthValue* e;
        float totalStrError = 0;
        float totalCountError = 0;
        int num = 0;
        for (int a=0; a < NUM_ATOMS; a++) {
            for (int b=0; b < NUM_ATOMS; b++) {
                if (a==b) continue;
                if (similarity[a][b]==NULL) continue;
//! @todo PTLFormulaeKit is from  old implementation
#ifdef OLD_BORKEN_CODE
                t = PTLFormulaeKit::similarityToInheritance(similarity[a][b],atoms[a],atoms[b],false);

                TS_ASSERT(t!=NULL);
                e = inheritance[a][b];
                cout << inheritance[a][b]->toString() << "\t"
                     << atoms[a]->toString() << "\t"
                     << atoms[b]->toString() << "\t"
                     << e->toString() << "\t"
                     << t->toString() << "\n";
                totalStrError += abs(e->getMean() - t->getMean());
                totalCountError += abs(e->getCount() - t->getCount());
#endif
                num++;
            }
        }
        float averageStrengthError = totalStrError / num;
        float averageCountError = totalCountError / num;
        cout << "Average Strength Error:" << averageStrengthError << "\n";
        cout << "Average Count Error:" << averageCountError << "\n";
        TS_ASSERT(averageStrengthError < STRENGTH_EPSILON);
        TS_ASSERT(averageCountError < COUNT_EPSILON);
    }


    void DISABLEtestInheritanceToSimilarity() {
        cout << "\n"
             << "A->B\t\t\tB->A\t\t\tA\t\t\tB\t\t\tA<->B(expected)\t\tA<->B(inferred)\n";
        TruthValue* t;
        TruthValue* e;
        float totalStrError = 0;
        float totalCountError = 0;
        int num = 0;
        for (int a=0; a < NUM_ATOMS; a++) {
            for (int b=0; b < NUM_ATOMS; b++) {
                if (a==b) continue;
                if ((inheritance[a][b]==NULL)||(inheritance[b][a]==NULL)) continue;
#ifdef OLD_BORKEN_CODE
//! @todo PTLFormulaeKit is from  old implementation
                t = PTLFormulaeKit::inheritanceToSimilarity(inheritance[a][b],
                                                            inheritance[b][a],
                                                            atoms[a],atoms[b]);

                TS_ASSERT(t!=NULL);
                e = similarity[a][b];
                cout << inheritance[a][b]->toString() << "\t"
                     << inheritance[b][a]->toString() << "\t"
                     << atoms[a]->toString() << "\t"
                     << atoms[b]->toString() << "\t"
                     << e->toString() << "\t"
                     << t->toString() << "\n";
                totalStrError += abs(e->getMean() - t->getMean());
                totalCountError += abs(e->getCount() - t->getCount());
#endif
                num++;
            }
        }
        float averageStrengthError = totalStrError / num;
        float averageCountError = totalCountError / num;
        cout << "Average Strength Error:" << averageStrengthError << "\n";
        cout << "Average Count Error:" << averageCountError << "\n";
        TS_ASSERT(averageStrengthError < STRENGTH_EPSILON);
        TS_ASSERT(averageCountError < COUNT_EPSILON);
    }

    void DISABLEtestRevisionSetWorld() {
        cout << "\n"
             << "A->B\t\t\tA'->B'\t\t\tA->B(expected)\t\tA->B(inferred)\n";
        TruthValue* e;
        TruthValue* d;
        TruthValue* t;
        float totalStrError = 0;
        float totalCountError = 0;
        int num = 0;
        for (int i=0; i < NUM_ATOMS; i++) {
            for (int j=0; j < NUM_ATOMS; j++) {
                for (int m=0; m < NUM_ATOMS; m++) {
                    for (int n=0; n < NUM_ATOMS; n++) {
                        if ((i!=n)&&(j==m)) {
                            if ((inheritance[i][j]==NULL) || (inheritance[m][n]==NULL)) continue;
                            e = inheritance[i][n];
#ifdef OLD_BORKEN_CODE
//! @todo PTLFormulaeKit is from  old implementation
                            d = PTLFormulaeKit::deduction(inheritance[i][j], inheritance[m][n],
                                                          atoms[i], atoms[j], atoms[n]);
                            TS_ASSERT(d!=NULL);
                            t = PTLFormulaeKit::revision(e,d);

                            TS_ASSERT(t!=NULL);
                            cout << e->toString() << "\t"
                                 << d->toString() << "\t"
                                 << e->toString() << "\t"
                                 << t->toString() << "\n";
                            totalStrError += abs(e->getMean() - t->getMean());
                            totalCountError += abs(e->getCount() - t->getCount());
#endif
                            num++;
                        }
                    }
                }
            }
        }
        float averageStrengthError = totalStrError / num;
        float averageCountError = totalCountError / num;
        cout << "Average Strength Error:" << averageStrengthError << "\n";
        cout << "Average Count Error:" << averageCountError << "\n";
        TS_ASSERT(averageStrengthError < STRENGTH_EPSILON);
        TS_ASSERT(averageCountError < COUNT_EPSILON);
    }
};

