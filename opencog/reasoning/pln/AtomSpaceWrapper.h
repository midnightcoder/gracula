/*
 * Copyright (C) 2002-2007 Novamente LLC
 * Copyright (C) 2008 by Singularity Institute for Artificial Intelligence
 * All Rights Reserved
 *
 * Authors:
 * Ari Heljakka
 * Joel Pitt
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef ATW_H
#define ATW_H

#include <time.h>
#include <queue>
#include <vector>

#include <boost/config.hpp>
#include <boost/smart_ptr.hpp>
#include <boost/lexical_cast.hpp>
// Attempted to use boost::bimap in boost 1.35+ but had too much trouble
//#include <boost/bimap/unordered_set_of.hpp>
//#include <boost/bimap/multiset_of.hpp>
//#include <map>
//#include <boost/bimap/bimap.hpp>

#include <opencog/atomspace/TimeServer.h>

#include "PLN.h"

#include "iAtomSpaceWrapper.h"
#include "rules/Rule.h"
#include "utils/fim.h"
#include "utils/Singleton.h"

//! The value at which PLN considers a TV a binary True.
#define PLN_TRUE_MEAN 0.989

//using namespace boost::bimaps;
#define GET_ASW ASW(NULL)

class AtomSpaceWrapperUTest;

namespace opencog {
namespace pln {

//! Construct a vtree around Handle h
vtree make_vtree(pHandle h);

// there exists a method to print (overloading <<) it see at the end of the file
typedef std::pair<Handle,VersionHandle> vhpair;

/** The bridge between the OpenCog AtomSpace and PLN.
 *
 * <h3>Fixing Fresh = true</h3>
 * 
 * The original version of Probabilistic Logic Networks made improper use of a
 * parameter in Novemente called \b fresh when adding new atoms to the
 * #opencog::AtomSpace. This allowed atoms to be added to the AtomSpace without
 * checking for duplicates. The end result is that atoms were no longer unique:
 * nodes
 * with the same name and type, or links that had the same outgoing set and
 * type, could duplicated. OpenCog does not allow this behaviour.
 * 
 * To fix this, all accesses to the AtomSpace now occur through the
 * AtomSpaceWrapper, which presents fake Handles to PLN and interprets them to a
 * combination of a real #opencog::Handle and a #opencog::VersionHandle. A
 * system of dummy contexts is used to emulate the behaviour of allowing
 * duplicate atoms in the AtomSpace by storing multiple #opencog::TruthValues
 * within a #opencog::CompositeTruthValue.
 *
 * The AtomSpaceWrapper did exist in the original PLN, but it was more for
 * carrying out normalisation and allowing different AtomSpace backends to be
 * used for efficiency reasons. 
 * 
 * Dummy contexts are represented as directed links. A root dummy context,
 * represented as a Concept Node with name "___PLN___" is used for the outgoing
 * set of dummy contexts in duplicate nodes. For links that are duplicates the
 * outgoing set of their dummy context consists of the dummy context of any
 * duplicate atoms they refer to, or the root dummy context if they refer to the
 * original version of an atom.
 * 
 * <h4> Node example </h4>
 *
 * If a node already exists, then a dummy context is created that links to the
 * root PLN dummy context.
 * 
 * E.g. say we have
 *
 * \code
 *  ConceptNode "x" <0.8, 0.9>
 * \endcode
 *
 * and we want to add a new node with the same name and type, but with TV
 * <0.5,0.5>. To achieve this we create a new dummy context link:
 *
 * \code
 *  dc <- OrderedLink (ConceptNode "___PLN___")
 * \endcode
 * 
 * \c dc is then used as the context for the new TV:
 * 
 * \code
 *  ConceptNode "x" <0.8, 0.9> [ Context dc <0.5, 0.5> ]
 * \endcode
 * 
 * <h4> Link example </h4>
 * 
 * If a link already exists, then the appropriate contexts for each outgoing
 * atom are linked by a new dummy context link (with the appropriate context
 * links of each atom in the outgoing set of the link in the same order as the
 * outgoing set of the existing link). This link's outgoing set/list is prefixed
 * by the root dummy context node if such a context to context link doesn't
 * exist, if it does exist then the context links are searched for the "bottom"
 * link and this is used as the prefix.
 * 
 * E.g. say we have an InheritanceLink composed of two ConceptNodes that both
 * have CompositeTruthValues:
 * 
 * \code
 *  dc_x <- OrderedLink (ConceptNode "___PLN___")
 *  dc_y <- OrderedLink (ConceptNode "___PLN___")
 *  InheritanceLink <0.8, 0.9>
 *      ConceptNode "x" <0.8, 0.9> [ Context dc_x <0.5, 0.5> ]
 *      ConceptNode "y" <0.8, 0.9> [ Context dc_y <0.1, 0.5> ]
 * \endcode
 * 
 * If we want to create another link with a different \c TruthValue, but between
 * the versions of x and y that are under the dummy context (instead of the
 * original \c TruthValues) then we get:
 * 
 * \code
 *  dc_x_y <- OrderedLink (dc_x dc_y)
 *  InheritanceLink <0.8, 0.9> [ Context dc_x_y <0.3, 0.5> ]
 *      ConceptNode "x" <0.8, 0.9> [ Context dc_x <0.5, 0.5> ]
 *      ConceptNode "y" <0.8, 0.9> [ Context dc_y <0.1, 0.5> ]
 * \endcode
 *
 * Then if we want to create yet another with a different truthvalue, we get:
 *
 * \code
 * dc_x_y_2 <- OrderedLink (dc_x_y dc_x dc_y)
 * InheritanceLink <0.8, 0.9> (Context dc_x_y_2 <0.777, 0.5>)
 *   ConceptNode "x" <0.8, 0.9> (Context dc_x <0.5, 0.5>)
 *   ConceptNode "y" <0.8, 0.9> (Context dc_y <0.1, 0.5>)
 * \endcode
 *
 * @todo short-term: intercept FW_VARIABLE_NODES and prevent them from being put in the
 * AtomSpace
 * @todo long-term: replace FW_VARIABLES_NODES with a string in the Vertex type.
 * @todo Normalisation of AtomSpace: EquivalenceLink <-> 2 x ImplicationLinks
 * @todo Explicit representation of ContextLinks (since AtomSpaceWrapper
 * maps each context TV to a separate Handle) or function to get context atom.
 */
class AtomSpaceWrapper : public iAtomSpaceWrapper
{
    // To allow test introspection
    friend class ::AtomSpaceWrapperUTest;

    //! How to represent the universe size
    // CONST_SIZE = constant value
    // REAL_SIZE  = actual size of knowledge/experience
    enum USizeMode_t { CONST_SIZE, REAL_SIZE };

    //! Universe size
    uint USize;
    //! How the universe size is being calculated
    USizeMode_t USizeMode;

    //! To get around the lack of a fresh=true method in OpenCog, and to allow
    //! multiple atoms with either the same type, name and/or outgoing set, we
    //! create a number of dummy PLN contexts, each providing a different
    //! VersionHandle with which to store multiple TruthValues in an Atom.
    //! This parameter indicates the name of the dummy contexts that have
    //! been used so far.
    std::set<VersionHandle> dummyContexts;
    
    //! This string is the prefix of PLN dummy context root Node
    const std::string rootContext;

    // typedef bimap< unordered_set_of< vhpair >, set_of<Handle> > vhmap_t;
    // typedef vhmap_t::value_type vhmap_pair_t;
    //! Bidrectional map with right index being PLN "handle", left a <handle,
    //! versionhandle> pair.
    //!
    //! @todo pHandle (typedefed above) is used to ensure
    //! distinctness from general OpenCog Handles... which is now defined  
    //! as a class. In the future. PLN may be adapted to use vhpairs
    //! directly instead of relying on the AtomSpaceWrapper.
    typedef std::map< pHandle, vhpair > vhmap_t;
    typedef vhmap_t::value_type vhmap_pair_t;
    typedef std::map< vhpair, pHandle > vhmap_reverse_t;
    typedef vhmap_reverse_t::value_type vhmap_reverse_pair_t;
    //! Instead of above bimap stuff, we will temporarily use two normal maps
    vhmap_t vhmap;
    vhmap_reverse_t vhmap_reverse;

    //! template to search a map for a value (instead of a key) this is to be
    //! removed once bimap is integrated
    //template < typename M, typename T > 
    //typename M::const_iterator findValueInMap (const M m, const T value) const
    //{
    //    typename M::const_iterator i;
    //    for (i = vhmap.begin(); i != vhmap.end(); i++) {
    //        if (i->second == value) {
    //            return i;
    //        }
    //    }
    //    return i;
    //}

    /**
     * Add a tree of non real atoms to AtomSpace.
     * @param v of atoms to add.
     * @param vi iterator to start adding atoms from
     * @param tvn what truth value they should be given
     * @param tvn what truth value they should be given
     * @param fresh allows atoms to be added with the same name/outgoing set.
     *              If fresh == false and the atom already exist then the new
     *              truth value is merged (via TruthValue::merge) with the old.
     *              Otherwise (fresh == true) then a new dummy context
     *              is associated to that new truth value.
     * @return The pHandle corresponding to the added atom
     */
    pHandle addAtom(vtree& v, vtree::iterator vi, const TruthValue& tvn,
                    bool fresh);

    //bool hasAppropriateContext(const Handle o, VersionHandle& vh, unsigned int
    //      i = 0) const;
    //bool isSubcontextOf(const Handle sub, const Handle super);

    //! used by filter_type to merge collections of handles.
    template<class T>
    void mergeCopy(T& a, const T& b) {
        //T ret(a);
        copy(b.begin(), b.end(), back_inserter(a));
        //return ret;
    }

    //! Used by getImportantHandles
    struct compareSTI {
        // Warning, uses real atomspace handles in comparison
        bool operator()(const Handle& a, const Handle& b) {
            return TLB::getAtom(a)->getAttentionValue().getSTI() >
                TLB::getAtom(b)->getAttentionValue().getSTI();
        }
    };
    
    // For monitoring additions to the AtomSpace from outside of PLN
    bool handleAddSignal(Handle h); //!< Signal handler for atom adds.
    bool handleRemoveSignal(Handle h); //!< Signal handler for atom removals.

    //! Whether AtomSpaceWrapper is listening for AtomSpace signals.
    bool watchingAtomSpace;

    boost::signals::connection c_add; //! Connection to add atom signals
    boost::signals::connection c_remove; //! Connection to remove atom signals

protected:
    AtomSpace *atomspace;

    //! Keep track of what FW Variables are in the system
    std::map<std::string,pHandle> variableShadowMap;

    //! Add Link via dummy contexts method
    pHandle addLinkDC(Type t, const pHandleSeq& hs, const TruthValue& tvn,
                      bool fresh);
    //! Add Node via dummy contexts method
    pHandle addNodeDC(Type t, const std::string& name, const TruthValue& tvn,
                      bool fresh);

    /** Add concrete atom using dummy contexts if it already exists
     * 
     * @note Contexts should have actual handles for links, or be empty for
     * nodes. This can be ensured by using the appropriate addNodeDC or
     * addNodeDC classes.
     * @param a Atom to be added
     * @param fresh allows atoms to be added with the same name/outgoing set.
     *              If fresh == false and the atom already exist then the new
     *              truth value is merged (via TruthValue::merge) with the old.
     *              Otherwise (fresh == true) then a new dummy context
     *              is associated to that new truth value.
     * @param context @todo add comment
     * 
     * @return The handle of the atom added.
     */
    pHandle addAtomDC(Atom &a, bool fresh,
                      HandleSeq contexts = HandleSeq());

    pHandle directAddLink(Type T, const pHandleSeq& hs, const TruthValue& tvn,
                          bool fresh);

public:

    //! Change whether AtomSpaceWrapper is listening for AtomSpace signals.
    void setWatchingAtomSpace(bool watching);
    //! Whether AtomSpaceWrapper is listening for AtomSpace signals.
    void isWatchingAtomSpace();

    //! Check whether a pHandle is known to the AtomSpaceWrapper
    bool isValidPHandle(const pHandle h) const;
    //! Convert a specific VersionHandled TruthValue to a pln handle
    // Note that realToFakeHandle cannot be const because it modifies vhmap
    // Or vhmap should be declared mutable
    pHandle realToFakeHandle(const Handle h, const VersionHandle vh);
    //! Convert a a real handle into a fake handle for each VersionedHandled TV
    pHandleSeq realToFakeHandle(const Handle hs);
    //! Convert real handles to pln pHandleSeq , optionally expanding to
    //! include every VersionHandled TV in each real handle
    pHandleSeq realToFakeHandles(const HandleSeq& hs, bool expand=false);
    //! Match each context in the outgoing set of "context" with the handles
    pHandleSeq realToFakeHandles(Handle h, Handle context);

    vhpair fakeToRealHandle(const pHandle f) const;

    //! Which XML files have been loaded by PLN to populate the AtomSpace.
    //! No longer accessed (but it is updated).
    std::set<std::string> loadedFiles;
    
    //! Debug method to display nodes
    void DumpCoreNodes(int logLevel);
    //! Debug method to display links
    void DumpCoreLinks(int logLevel);
    //! Debug method to display all atoms of Type T 
    void DumpCore(Type T);

    //! return the size of the universe
    //! @todo get the universe from the real AtomSpace if USizeMode == REAL_SIZE
    unsigned int getUniverseSize() const { return USize; }

    //! set the universe size (only if USizeMode == CONST_SIZE)
    void setUniverseSize(USizeMode_t _USizeMode, unsigned int _USize)
    {
        assert(_USizeMode == CONST_SIZE);
        USizeMode = _USizeMode;
        USize = _USize;
    }

    //! Get handles with type t and name str optionally subtypes as well
    virtual Btr<std::set<pHandle> > getHandleSet(Type T,
                                                 const std::string& name,
                                                 bool subclass = false);
    //! Get handle of node with type t and name str
    pHandle getHandle(Type t,const std::string& str);
    //! Get handle of link with type t and outgoing set 
    pHandle getHandle(Type t,const pHandleSeq& outgoing);
    // helper methods for getHandle
    inline pHandle getHandle(Type t, pHandle ha) {
        pHandleSeq oset;
        oset.push_back(ha);
        return getHandle(t, oset);
    }
    inline pHandle getHandle(Type t, pHandle ha, pHandle hb) {
        pHandleSeq oset;
        oset.push_back(ha);
        oset.push_back(hb);
        return getHandle(t, oset);
    }

    pHandleSeq getOutgoing(const pHandle h);

    pHandle getOutgoing(const pHandle h, const int i);

    //! Get the incoming set for an atom
    pHandleSeq getIncoming(const pHandle h);

    Type getType(const pHandle h) const;
    std::string getName(const pHandle h) const;

    //! Reset the AtomSpace
    void reset();

    //! Initialize new AtomSpaceWrapper with const universe size
    AtomSpaceWrapper(AtomSpace* as);
    virtual ~AtomSpaceWrapper() {}

    //! Load axioms from given xml filename
    bool loadAxioms(const std::string& path);
    //! Load other axioms from given xml filename and optionally replace?
    bool loadOther(const std::string& path, bool replaceOld);

    /**
     * Update the TruthValue of a given pHandle. If the given handle
     * does not point an atom (UNDEFINED or Type) then an OC_ASSERT is raised.
     *
     * @param h Handle to apply the update on
     * @param tv TruthValue to update
     * @param fresh If fresh == false then the new truth value is merged
     *              (via TruthValue::merge) with the old.
     *              Otherwise (fresh == true) then a new dummy context
     *              is associated to that new truth value.
     *
     * @return The pHandle updated. Note that it is note necessarily
     *         equal to h because it associate automatically
     *         a new dummy context to it, which gets translated a different
     *         pHandle.
     */
    pHandle updateTV(pHandle h, const TruthValue& tv, bool fresh);

    /**
     * Add atom from tree vertex
     * @param tvn what truth value they should be given
     * @param fresh allows atoms to be added with the same name/outgoing set
     * @param       If fresh == false then the new truth value is merged
     *              (via TruthValue::merge) with the old.
     *              Otherwise (fresh == true) then a new dummy context
     *              is associated to that new truth value.
     * @return the pHandle corresponding to the atom added
     */
    pHandle addAtom(tree<Vertex>&, const TruthValue& tvn, bool fresh=false);

    //! Add link, pure virtual
    //! @param tvn what truth value they should be given
    //! @param fresh allows atoms to be added with the same name/outgoing set
    virtual pHandle addLink(Type T, const pHandleSeq& hs, const TruthValue& tvn,
                            bool fresh=false)=0;

    // helper methods for addLink
    inline pHandle addLink(Type t, pHandle ha, const TruthValue& tvn,
                           bool fresh=false)
    {
        pHandleSeq oset;
        oset.push_back(ha);
        return addLink(t, oset, tvn, fresh);
    }
    inline pHandle addLink(Type t, pHandle ha, pHandle hb,
                           const TruthValue& tvn, bool fresh=false)
    {
        pHandleSeq oset;
        oset.push_back(ha);
        oset.push_back(hb);
        return addLink(t, oset, tvn, fresh);
    }
    inline pHandle addLink(Type t, pHandle ha, pHandle hb, pHandle hc,
                           const TruthValue& tvn, bool fresh=false)
    {
        pHandleSeq oset;
        oset.push_back(ha);
        oset.push_back(hb);
        oset.push_back(hc);
        return addLink(t, oset, tvn, fresh);
    }

    //! Add node, pure virtual
    //! @param tvn what truth value they should be given
    //! @param fresh allows atoms to be added with the same name/outgoing set
    virtual pHandle addNode(Type T, const std::string& name,
                            const TruthValue& tvn, bool fresh=false)=0;

    //! Remove Atom
    virtual bool removeAtom(pHandle h);

    //! return a random handle of type T
    pHandle getRandomHandle(Type T);

    //! get a number of high STI handles
    pHandleSeq getImportantHandles(int number);

    //! Whether the handle h has high enough TruthValue to be consider a binary True.
    //! @todo move to TruthValue classes
    bool binaryTrue(pHandle h);

    //! @todo Move the below conversion tools in a Converter class
    
    //! Wrap h in a NOT_LINK and return that 
    pHandle invert(pHandle h);
    //! Convert from AND to OR link
    pHandle AND2ORLink(pHandle& andL, Type _ANDLinkType, Type _ORLinkType);
    //! Convert from Equivalence to Implication link
    hpair Equi2ImpLink(pHandle& exL);
    //! Convert from Existance to For All link
    pHandle Exist2ForAllLink(pHandle& exL);
    //! Convert from OR to AND link
    pHandle OR2ANDLink(pHandle& andL);
    //! Convert from AND to OR link
    pHandle AND2ORLink(pHandle& andL);
    
    Handle getNewContextLink(Handle h, HandleSeq destContexts);

    //! Whether to generate CrispTheoremRules for all crisp theorems
    //! and add them to CrispTheoremRule::thms.
    bool archiveTheorems;

    //! Generate CrispTheoremRules for all crisp theorems in AtomSpace
    //! and add to CrispTheoremRule::thms.
    void makeCrispTheorems();

    //! Generate a CrispTheoremRule for crisp theorem pointed to by
    //! p then and add to CrispTheoremRule::thms.
    //! A crisp theorem has the format:
    //! ImplicationLink ( AND < tv 1.0 > (...), result )
    void makeCrispTheorem(pHandle p);

    //! returns whether the type of h is T or inherits from T
    bool isSubType(pHandle h, Type T);
    //! returns whether 
    bool inheritsType(Type subT, Type superT) const;

    void HandleEntry2HandleSet(HandleEntry& src, std::set<Handle>& dest) const;
    const TruthValue& getTV(pHandle h) const;

    bool isType(const pHandle h) const;

    const TimeServer& getTimeServer() const;

    /** Retrieve the arity of a given link */
    int getArity(pHandle) const;

    pHandleSeq filter_type(Type t);

    bool equal(const HandleSeq& lhs, const HandleSeq& rhs);
    bool equal(Handle A, Handle B);

    int getFirstIndexOfType(pHandleSeq hs, Type T) const;
    bool symmetricLink(Type T);
    bool isEmptyLink(pHandle h);
    bool hasFalsum(pHandleSeq hs);
    bool containsNegation(pHandle ANDlink, pHandle h);

    //! return the type of the root of _target
    Type getTypeV(const tree<Vertex>& _target) const;

    bool allowFWVarsInAtomSpace;

    //for debugging
    std::string vhmapToString() const;
    std::string pHandleToString(pHandle ph) const;

// TODELETE
//  combo::NMCore* getCore() const { return core; }
//  std::vector<atom> LoadAnds(const std::string& path);
//  int implicationConstruction();
//  bool hasFalsum(float minAllowedError = 0.5) { return false; }
//  void VariableMPforms(const atom& src, set<atom, lessatom_ignoreVarNameDifferences>& res,
//                     set<subst>* forbiddenBindings);

};

/*
 * Operator to check that the outgoing pHandles of 2 pHandles
 * both at a given index are equal
 */
struct EqOutgoing : public unary_function<pHandle, bool> {
    EqOutgoing(const pHandle h, const int idx, AtomSpaceWrapper* asw)
        : _h(h), _idx(idx), _asw(asw)
    {}
    bool operator()(const pHandle h)
    {
        return _asw->getOutgoing(_h, _idx) == _asw->getOutgoing(h, _idx);
    }
private:
    const pHandle _h;
    const int _idx;
    AtomSpaceWrapper* _asw;
};

/**
 * Singleton instance of AtomSpaceWrapper
 * (following meyer's design pattern)
 */
AtomSpaceWrapper* ASW(AtomSpace *a = NULL);

/** Passes the atoms via FIM analyzer. To turn this off, set FIM=0 in Config.
*/
class FIMATW : public AtomSpaceWrapper
{
    fim::pat_id next_free_pat_id;

// TODELETE
//  std::map<atom,int,lessatom> node2pat_id;
public:
    /// Semi-haxx::
    fim::grim myfim;

    FIMATW(AtomSpace *a) : AtomSpaceWrapper(a), next_free_pat_id(30001) {}
    virtual ~FIMATW() {}

    pHandle addLink(Type T, const pHandleSeq& hs, const TruthValue& tvn,
                    bool fresh);
    pHandle addNode(Type T, const std::string& name, const TruthValue& tvn,
                    bool fresh);
// TODELETE:
//  FIMATW(combo::NMCore* core) : AtomSpaceWrapper(core), next_free_pat_id(30001) {}
};

/** Normalizes atoms before passing forward */
class NormalizingATW : public FIMATW
{
    NormalizingATW(AtomSpace *a);

    template<typename T>
    bool cutVector(const std::vector<T>& src, int index, std::vector<T>& dest)
    {
        dest.clear();

        for (int i = 0; i < src.size(); i++)
            if (i != index)
                dest.push_back(src[i]);

        return index < src.size();
    }

public:
    virtual ~NormalizingATW() {}
       
    static NormalizingATW& getInstance(AtomSpace *a = NULL) {
        if (a == NULL)
            a = server().getAtomSpace();
        static NormalizingATW* instance = new NormalizingATW(a);
        return *instance;
    }
    
    pHandle addLink(Type T, const pHandleSeq& hs, const TruthValue& tvn,
            bool fresh);
    pHandle addNode(Type T, const std::string& name, const TruthValue& tvn,
            bool fresh);

    // TODELETE:
    //Btr<set<Handle> > getHandleSet(Type,const string&,bool = false);

};

/** Forwards the requests without normalizing */
class DirectATW : public AtomSpaceWrapper
{
    DirectATW(AtomSpace* as);
public:
    virtual ~DirectATW() { }

    static DirectATW& getInstance(AtomSpace *as = NULL) {
        if (as == NULL)
            as = server().getAtomSpace();
        static DirectATW* instance = new DirectATW(as);
        return *instance;
    }
    
    pHandle addLink(Type T, const pHandleSeq& hs, const TruthValue& tvn,
                    bool fresh);
    pHandle addNode(Type T, const std::string& name, const TruthValue& tvn,
                    bool fresh);
    //Btr<set<Handle> > getHandleSet(Type, const string&, bool = false);

};

// TODELETE
/*using namespace boost;
class LocalATW : public AtomSpaceWrapper, public Singleton<LocalATW>
{
    LocalATW();

    //vector<Handle> mindShadow;
    map<Type, shared_ptr<set<Handle> > > mindShadowMap;
    map<Type, std::queue<std::set<Handle>::iterator > > q;
    
    unsigned long capacity;
    
public:
    virtual ~LocalATW() { }
    friend class Singleton<LocalATW>;
    
    static bool inHandleSet(Type T, const HandleSeq& hs, shared_ptr<set<Handle> > res, Handle* ret);
    static bool inHandleSet(Type T, const string& name, shared_ptr<set<Handle> > res, Handle* ret);
  
    Handle addLink(Type T, const HandleSeq& hs, const TruthValue& tvn, bool fresh, bool managed=true);
    Handle addNode(Type T, const std::string& name, const TruthValue& tvn, bool fresh, bool managed=true);

    Btr<set<Handle> > getHandleSet(Type T, const string& name, bool subclass = false) const;
    
    void ClearAtomSpace();
    void DumpCore(Type T = 0);
    void SetCapacity(unsigned long atoms);
}; */


}} //~namespace opencog::pln

namespace std { 
//Nil: I wrap it under that namespace to avoid a weird ambiguous overload...
namespace overloadmadness {
//overload of operator<< to print vhpair
inline std::ostream& operator<<(std::ostream& out,
                                const opencog::pln::vhpair& vhp) {
    out << "(Handle=" << vhp.first
        << ",VersionHandle=" << vhp.second << ")";
    return out;
}
} // ~namespace overloadmadness

//overload of operator<< to print std::pair<pHandle,vhpair>
inline std::ostream& operator<<(std::ostream& out,
                                const std::pair<opencog::pln::pHandle,
                                                opencog::pln::vhpair>& pvp) {
    using namespace overloadmadness;
    out << "(pHandle=" << pvp.first
        << ",vhpair=" << pvp.second << ")";
    return out;
}
} // ~namespace std


#endif
